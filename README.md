# war-card-game

## Overview

This repo implements the game of war as described in [https://en.wikipedia.org/wiki/War_(card_game)].
It is implemented in Python using Pytest for testing.

### Usage
#### Installing
This repo does not require any third-party packages to run outside of a base Python 3.7-3.9 installation.

To setup testing, one requirement, pytest is specified in `requirements.txt`:
```
python -m pip install -r requirements.txt
```

#### Running
A basic demo is available in `main.py`. This file sets up a game of war using the wikipedia version of the rules and just 1 suit of 13 cards out of a standard deck.
```
python main.py
```

## Structure
The code is split into 4 main components:
- game loop
- cards
- games
- players

### Game Loop
The game loop (in `play.py`) runs the main game loop. It is responsible for setting up all of the other components and running the game.
Each loop, it prints out the current state of the game.
Upon completion, it prints out the result of the game.

### Cards
`Card` (in `cards/__init__.py`) is the base class for all types of cards. Two types of cards are currently implemented:
- StandardCard - A standard 4 suit, 52 card deck
- SmallStandardCard - 1 suit of 13 cards

Cards are decoupled as a separate component so it can be easily swapped out for another. In the real world, consider the case where a few cards are missing from a deck. In this case, it is trivial to subclass a `Card` and serve custom decks of cards. `SmallStandardCard` is an example of this. It subclasses `StandardCard` and modifies the deck served while inheriting comparison methods.
Using this mechanism, the Bettelmann variant mentioned on Wikipedia can be easily implemented.

There is no separate abstraction for a deck. As the deck of cards used to play war is closely tied to the kind of cards being used, they can exist together in one class.

### Games
`Game` (in `games/__init__.py`) is the base class for all type of games. One type of game is currently implemented:
- WikipediaGame - The game of war as described on Wikipedia

Game behavior is decoupled from the game loop so it can be easily changed. Wikipedia describes how the rules of War can frequently differ ("Most descriptions of War are unclear about what happens if a player runs out of cards during a war"). If the wanted tie behavior changes, instead of needing to reimplement the entire game loop, just the separate game rules can be modified instead.

Furthermore, decoupling the games rules from the game loop makes the code more usable. Since all of the game behavior is abstract and must be overridden, if the game loop were a part of the `Game` classes, it may lead to accidently overriding the loop.

### Players
`Player` (in `players/__init__.py`) is the base class for all types of players. One type of player is currently implemented:
- NaivePlayer - A player that returns cards to their deck in the order in which they receive them

The primary purpose of a `Player` is to store the the players deck and hand. Initially, it was a part of the game loop. However, it has been decoupled to account for vague game rules. As per Wikipedia, "the rules often do not specify in which order the cards should be returned to the deck".
If the rules specify the order in which cards must be returned to the deck, then `Game:return_cards_to_decks` can return all the cards to all the players' decks. However, it the rules do not specify this, then the `Game` can defer to each `Player:return_cards_to_deck` to allow for each player to have an individual strategy.

## Testing + CI
Testing is implemented using pytest and the `test_*` files. Each component is tested separately, apart from the game loop, which is tested end-to-end. Where possible, as in `test_cards.py` tests are autogenerated so that they can be more comprehensive.

Testing can be run using
```
python -m pytest .
```

Testing also occur in CI. This repo uses Github Actions to run formatting and testing automatically on push.

### CI Formatting
This repo uses `black` to format all Python code. `black` is run in CI on push to ensure that code is properly formatted.

### CI Testing
CI runs this repo's tests across 3 Python versions, 3.7, 3.8, and 3.9. Since this repo does not contain any platform specific code, CI testing only occurs on one platform (Ubuntu Linux). If this repo included platform specific code, the CI matrix would be extended to include Windows and MacOS.

An example CI run is available at https://github.com/TheTripleV/war-card-game/actions/runs/965428820

## Assumptions

### There can only be one winner
The game loop expects that there is always a winner in a game. A game cannot tie.

## With More Time
If I had more time, then I would work on:
- Cleaning up the implementation of `wikipediagame.py`
- Adding more comprehensive end-to-end testing.
  Expected results for games of war are dependant on the Card, Game, and Players used and take significant time to calculate manually.
- Adding more support for variations. Currently, Bettelmann can be easily added by creating a new Card class and new Game class. I would add support for this. To implement the other mentioned variations, Casino War, and Prisoners of War, the game loop may need to provide more information of the state of the game to the `Game` classes.
- Improve dependency management. Currently, while the only dependency is for testing, it is not version locked. I would lock pytest to a specific version. Furthermore, as locking a dependency does not lock its dependencies (transitive dependencies), I would use Poetry to lock all dependencies, including transitive ones.
- Backport this code to Python 3.6. The only Python 3.7+ code used is dataclasses. By importing a backported version of this, this repo can support Python 3.6.
- Add `isort` to CI. `isort` has been used to format the imports in each file but has not been added to CI.
